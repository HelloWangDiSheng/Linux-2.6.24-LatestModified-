#ifndef _ASM_GENERIC_BITOPS_FFS_H_
#define _ASM_GENERIC_BITOPS_FFS_H_

/*查找第一个已置位的比特位位置（而非索引）。该函数同C库和编译器内置的ffs函数是同样的
定义方式，因此同前述ffz（man ffs）是不同的编程思想。该函数的思想是先从低位开始，设置
字长的一半作为比较长度，测试比较长度的值是否为0，如果是0，更新比较位置和减半比较长度，
重新开始比较，直到比较长度小于1时结束，返回已更新的位置。如果不是0，则同样的方法比较
已经比较的区域，直至比较长度小于1结束，返回更新的位置*/
static inline int ffs(int x)
{
	int r = 1;
	/*值为0直接返回0*/
	if (!x)
		return 0;
	/*如果低16位位0，则将判断位置右移16位，开始计数位累计16，判断高16位*/
	if (!(x & 0xffff))
	{
		x >>= 16;
		r += 16;
	}
	/*如果低8位位0，则将判断位置右移8位，开始计数位累计8，判断高8位*/
	if (!(x & 0xff))
	{
		x >>= 8;
		r += 8;
	}
	/*如果低4位位0，则将判断位置右移4位，开始计数位累计4，判断高4位*/
	if (!(x & 0xf))
	{
		x >>= 4;
		r += 4;
	}
	/*如果低2位位0，则将判断位置右移2位，开始计数位累计2，判断高2位*/
	if (!(x & 3))
	{
		x >>= 2;
		r += 2;
	}
	/*如果低1位位0，则将判断位置右移1位，开始计数位累计1，判断高1位*/
	if (!(x & 1)) {
		x >>= 1;
		r += 1;
	}
	return r;
}

#endif /* _ASM_GENERIC_BITOPS_FFS_H_ */
