/*ioport.h定义了一些检测、分配、释放系统资源的函数*/
#ifndef _LINUX_IOPORT_H
#define _LINUX_IOPORT_H

#include <linux/compiler.h>
#include <linux/types.h>

/*linux提供了一个通用架构，用于在内存中构建数据结构。这些结构描述了系统中可用的资源
，使得内核代码能够管理和分配资源。其中关键的数据结构是resource，在内核中以树状形式
表示。用于连接parent、child和sibling成员的规则很简单：（1）每个子节点都有一个父节点
（2）一个父节点可以有任意数目的子节点（3）同一个父节点的所有子节点，会连接到兄弟结点
链表上。在内存中表示数据结构时，必须注意以下问题：（1）尽管每个子节点都有一个指针指向
父节点，但父节点只有一个指针指向第一个子节点，所有其它子节点都通过兄弟结点链表访问（2）
指向父节点的指针同样可以为空，在这种情况下，说明已经没有更高层次的结点了*/
struct resource
{
	/*资源所属地址空间的起始地址*/
	resource_size_t start;
	/*资源所属地址空间的终止地址*/
	resource_size_t end;
	/*存储了一个字符串，以便给资源赋予一个有意义的名字，资源名称实际与内核无关，但
	在以可读形式输出资源列表（在proc文件系统中）时比较有用*/
	const char *name;
	/*用于根准确地描述资源及当前状态*/
	unsigned long flags;
	/*父节点指针。由于是单链表，因此遍历的时候需要一个指针指向当前结点，另一个指向
	当前结点的地址，完成遍历过程中的增加删除操作，当然了，在操作期间要持有保护资源
	的读写自旋锁*/
	struct resource *parent;
	/*兄弟结点指针连接同一父节点的所有子节点*/
	struct resource *sibling;
	/*子节点指针只指向第一个子节点*/
	struct resource *child;
};

/*资源列表*/
struct resource_list
{
	/*资源列表已单链表的形式连接*/
	struct resource_list *next;
	/*指向资源结点*/
	struct resource *res;
	/*资源对应的pci设备*/
	struct pci_dev *dev;
};

/*
 * IO resources have these defined flags.
 */
/*IO资源拥有已定义的标识*/
/*总线特有的比特位。系统中最多可定义256（1<<8）条PCI总线*/
#define IORESOURCE_BITS		0x000000ff	/* Bus-specific bits */
/*资源类型*/
/*io端口*/
#define IORESOURCE_IO					0x00000100
/*io内存*/
#define IORESOURCE_MEM					0x00000200
/*中断请求*/
#define IORESOURCE_IRQ					0x00000400
/*DMA*/
#define IORESOURCE_DMA					0x00000800

#define IORESOURCE_PREFETCH				0x00001000	/* No side effects */
#define IORESOURCE_READONLY				0x00002000
#define IORESOURCE_CACHEABLE			0x00004000
#define IORESOURCE_RANGELENGTH			0x00008000
#define IORESOURCE_SHADOWABLE			0x00010000
#define IORESOURCE_BUS_HAS_VGA			0x00080000

#define IORESOURCE_DISABLED				0x10000000
#define IORESOURCE_UNSET				0x20000000
#define IORESOURCE_AUTO					0x40000000
/*驱动可以标识当前资源繁忙不可用*/
#define IORESOURCE_BUSY					0x80000000

/* ISA PnP IRQ specific bits (IORESOURCE_BITS) */
#define IORESOURCE_IRQ_HIGHEDGE				(1<<0)
#define IORESOURCE_IRQ_LOWEDGE				(1<<1)
#define IORESOURCE_IRQ_HIGHLEVEL			(1<<2)
#define IORESOURCE_IRQ_LOWLEVEL				(1<<3)
#define IORESOURCE_IRQ_SHAREABLE			(1<<4)

/* ISA PnP DMA specific bits (IORESOURCE_BITS) */
#define IORESOURCE_DMA_TYPE_MASK			(3<<0)
#define IORESOURCE_DMA_8BIT					(0<<0)
#define IORESOURCE_DMA_8AND16BIT			(1<<0)
#define IORESOURCE_DMA_16BIT				(2<<0)

#define IORESOURCE_DMA_MASTER				(1<<2)
#define IORESOURCE_DMA_BYTE					(1<<3)
#define IORESOURCE_DMA_WORD					(1<<4)

#define IORESOURCE_DMA_SPEED_MASK			(3<<6)
#define IORESOURCE_DMA_COMPATIBLE			(0<<6)
#define IORESOURCE_DMA_TYPEA				(1<<6)
#define IORESOURCE_DMA_TYPEB				(2<<6)
#define IORESOURCE_DMA_TYPEF				(3<<6)

/* ISA PnP memory I/O specific bits (IORESOURCE_BITS) */
#define IORESOURCE_MEM_WRITEABLE			(1<<0)	/* dup: IORESOURCE_READONLY */
#define IORESOURCE_MEM_CACHEABLE			(1<<1)	/* dup: IORESOURCE_CACHEABLE */
#define IORESOURCE_MEM_RANGELENGTH			(1<<2)	/* dup: IORESOURCE_RANGELENGTH */
#define IORESOURCE_MEM_TYPE_MASK			(3<<3)
#define IORESOURCE_MEM_8BIT					(0<<3)
#define IORESOURCE_MEM_16BIT				(1<<3)
#define IORESOURCE_MEM_8AND16BIT			(2<<3)
#define IORESOURCE_MEM_32BIT				(3<<3)
#define IORESOURCE_MEM_SHADOWABLE			(1<<5)	/* dup: IORESOURCE_SHADOWABLE */
#define IORESOURCE_MEM_EXPANSIONROM			(1<<6)

/* PCI ROM control bits (IORESOURCE_BITS) */
#define IORESOURCE_ROM_ENABLE				(1<<0)	/* ROM is enabled, same as PCI_ROM_ADDRESS_ENABLE */
#define IORESOURCE_ROM_SHADOW				(1<<1)	/* ROM is copy at C000:0 */
#define IORESOURCE_ROM_COPY					(1<<2)	/* ROM is alloc'd copy, resource field overlaid */
#define IORESOURCE_ROM_BIOS_COPY			(1<<3)	/* ROM is BIOS copy, resource field overlaid */

/* PCI control bits.  Shares IORESOURCE_BITS with above PCI ROM.  */
#define IORESOURCE_PCI_FIXED				(1<<4)	/* Do not move resource */

/* PC/ISA/whatever - the normal PC address spaces: IO and memory */
/*PCI/ISA等任何普通PC地址空间：IO和内存*/
/*声明一个io端口资源变量ioport_resource，全局io端口根资源变量*/
extern struct resource ioport_resource;
/*声明一个io内存资源变量iomen_resource，全局io内存根资源变量*/
extern struct resource iomem_resource;

extern int request_resource(struct resource *root, struct resource *new);
extern int release_resource(struct resource *new);
extern int insert_resource(struct resource *parent, struct resource *new);
extern int allocate_resource(struct resource *root, struct resource *new,
			     		resource_size_t size, resource_size_t min, resource_size_t max,
			     		resource_size_t align, void (*alignf)(void *, struct resource *,
						resource_size_t, resource_size_t), void *alignf_data);
int adjust_resource(struct resource *res, resource_size_t start, resource_size_t size);

/* Convenience shorthand with allocation */
#define request_region(start,n,name)	__request_region(&ioport_resource, (start), (n), (name))
#define request_mem_region(start,n,name) __request_region(&iomem_resource, (start), (n), (name))
#define rename_region(region, newname) do { (region)->name = (newname); } while (0)

extern struct resource * __request_region(struct resource *, resource_size_t start,
													resource_size_t n, const char *name);

/* Compatibility cruft */
#define release_region(start,n)	__release_region(&ioport_resource, (start), (n))
#define check_mem_region(start,n)	__check_region(&iomem_resource, (start), (n))
#define release_mem_region(start,n)	__release_region(&iomem_resource, (start), (n))

extern int __check_region(struct resource *, resource_size_t, resource_size_t);
extern void __release_region(struct resource *, resource_size_t, resource_size_t);

static inline int __deprecated check_region(resource_size_t s, resource_size_t n)
{
	return __check_region(&ioport_resource, s, n);
}

/* Wrappers for managed devices */
struct device;
#define devm_request_region(dev,start,n,name) \
	__devm_request_region(dev, &ioport_resource, (start), (n), (name))
#define devm_request_mem_region(dev,start,n,name) \
	__devm_request_region(dev, &iomem_resource, (start), (n), (name))

extern struct resource * __devm_request_region(struct device *dev,
				struct resource *parent, resource_size_t start,
				resource_size_t n, const char *name);

#define devm_release_region(start,n) \
	__devm_release_region(dev, &ioport_resource, (start), (n))
#define devm_release_mem_region(start,n) \
	__devm_release_region(dev, &iomem_resource, (start), (n))

extern void __devm_release_region(struct device *dev, struct resource *parent,
				  resource_size_t start, resource_size_t n);

#endif	/* _LINUX_IOPORT_H */
